use ethers_core::utils::hex;
use std::str::FromStr;

use reth_primitives::{Bytes, H256, U256};
use reth_rlp::Encodable;

use rs_node::types::*;

// Taken from: reth
// Test vector from: https://eips.ethereum.org/EIPS/eip-2481
#[test]
fn test_encode_header() {
	let expected = hex::decode("f901f9a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000b90100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008208ae820d0582115c8215b3821a0a827788a00000000000000000000000000000000000000000000000000000000000000000880000000000000000").unwrap();
	let header = Header {
		difficulty: U256::from(0x8ae_u64),
		number: 0xd05_u64,
		gas_limit: 0x115c_u64,
		gas_used: 0x15b3_u64,
		timestamp: 0x1a0a_u64,
		extra_data: Bytes::from_str("7788").unwrap(),
		ommers_hash: H256::zero(),
		state_root: H256::zero(),
		transactions_root: H256::zero(),
		receipts_root: H256::zero(),
		..Default::default()
	};
	let mut data = vec![];
	header.encode(&mut data);
	let expected_hash = H256::from_str("0x8c2f2af15b7b563b6ab1e09bed0e9caade7ed730aec98b70a993597a797579a9").unwrap();
	assert_eq!(header.hash_slow(), expected_hash);
	assert_eq!(hex::encode(&data), hex::encode(expected));
	assert_eq!(header.length(), data.len());
}
